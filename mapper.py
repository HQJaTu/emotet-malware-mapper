#!/usr/bin/env python3

# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=python

import re
import argparse
import ipaddress
import json
import geoip2.database
import geoip2.errors
import dns.resolver  # from pip dnspython3

BLACKLISTED_HOSTNAMES = (
    'twitter.com',
    'pastebin.com',
    'www.avast.com',
    'capesandbox.com',
    'github.com'
)
BLACKLISTED_CATEGORIES = (
    'Loader Report'
)

def host_info(host, geoip_reader):
    try:
        ip = ipaddress.ip_address(host)
    except ValueError:
        ip = None

    if ip:
        # See if this IP-address is bogus.
        if not ip.is_global:
            return None

        # Lose object, convert to string
        ip = str(ip)
    else:
        try:
            answers = dns.resolver.query(host, 'A')
        except (dns.resolver.NXDOMAIN, dns.resolver.NoNameservers, dns.resolver.NoAnswer):
            # Nope. Didn't resolve
            return None

        for rdata in answers:
            ip = rdata.address

    # Go query
    try:
        response = geoip_reader.city(ip)
    except geoip2.errors.AddressNotFoundError:
        return ip, None, None

    return host, ip, response.location.latitude, response.location.longitude


def file_parser(filename, geoip_reader, output_dict, callback):
    category = None
    epoch = None
    host_count = 0
    with open(filename) as file:
        for line in file:
            match = re.search(r'^####\s+(.+)\s+####', line)
            if match:
                category = match.group(1)
                if category in BLACKLISTED_CATEGORIES:
                    category = None
                    continue

                # Determine Epoch
                match = re.search(r'^Epoch (\d) ', category)
                if not match:
                    continue
                epoch = int(match.group(1))

                # Simplify category into C2 or downloader
                if 'C2' in category:
                    category = 'C2'
                else:
                    category = 'Download link'
                continue

            match = re.search(r'^http(s)?://([^/]+)/', line)
            if match:
                host_to_query = match.group(2)
            else:
                match = re.search(r'^(\d+\.\d+\.\d+\.\d+):\d+', line)
                if match:
                    host_to_query = match.group(1)
                else:
                    continue

            if not category or not epoch or host_to_query in BLACKLISTED_HOSTNAMES:
                if not category:
                    print("No category!")
                if not epoch:
                    print("No epoch!")
                continue

            # print(line)
            print("%04d (%d, %s): %s" % (host_count, epoch, category, host_to_query))
            if host_to_query in output_dict:
                continue

            # Process this baby
            host_count += 1
            info = callback(host_to_query, geoip_reader)
            if not info:
                continue

            if epoch not in output_dict:
                output_dict[epoch] = dict()
            if category not in output_dict[epoch]:
                output_dict[epoch][category] = []
            output_dict[epoch][category].append(info)


def write_json(filename, output):
    with open(filename, 'w') as f:
        json.dump(output, f)


def main():
    parser = argparse.ArgumentParser(description='Hostname extractor')
    parser.add_argument('info_file', metavar='EMORY-INFO-FILE',
                        help='Filename with Emory Malware C2 and download points')
    parser.add_argument('host_info_json_file', metavar='OUTPUT-JSON-FILE',
                        help='Filename to output data')
    parser.add_argument('--geoip-db-file', metavar='GEOIP-DATABASE-FILE', default='/usr/share/GeoIP/GeoLite2-City.mmdb',
                        help='Maxmind GeoLite2 City database')
    args = parser.parse_args()

    # Prepare
    reader = geoip2.database.Reader(args.geoip_db_file)
    output = dict()

    # Go parse the input file
    file_parser(args.info_file, reader, output, lambda h, r: host_info(h, r))

    # Go produce a JSON-result of the hard work done
    write_json(args.host_info_json_file, output)


if __name__ == '__main__':
    main()
